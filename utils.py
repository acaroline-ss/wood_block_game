from cst import *
import random

def are_blocks_equal(b1, b2):
    """Check if two blocks have identical shape and filled cells.
    
    Args:
        b1, b2: Blocks to compare
        
    Returns:
        True if blocks are identical
    """
    return (len(b1) == len(b2) and 
            all(len(r1) == len(r2) and all(c1 == c2 for c1, c2 in zip(r1, r2))
            for r1, r2 in zip(b1, b2)))

def get_rotations(block):
    """Generate all unique 90-degree rotations of a given block.
    
    Rotations are generated by transposing and reversing rows (90Â° clockwise).
    Only unique rotations are kept (handles symmetric blocks efficiently).
    
    Args:
        block: 2D matrix representing the block (1=filled, 0=empty)
        
    Returns:
        List of unique rotated block matrices
    """
    rotations = [block]
    current = block
    
    for _ in range(3):
        current = [list(row)[::-1] for row in zip(*current)]
        if not any(are_blocks_equal(current, rot) for rot in rotations):
            rotations.append(current)
    return rotations

def can_place_block(block, x, y, grid, GRID_SIZE, tolerance=None):
    """Check if block can be placed at (x,y) without overlaps or going out-of-bounds.
    
    Args:
        block: 2D block matrix to place
        x, y: Top-left grid coordinates for placement
        grid: Current game grid state
        GRID_SIZE: Dimensions of the grid
        tolerance: Unused (kept for compatibility)
        
    Returns:
        True if placement is valid, False otherwise
    """
    h, w = len(block), len(block[0])
    if x < 0 or y < 0 or x + w > GRID_SIZE or y + h > GRID_SIZE:
        return False
    return not any(cell and grid[y+dy][x+dx] != BLACK 
                  for dy, row in enumerate(block)
                  for dx, cell in enumerate(row))

def place_block(block, x, y, color, grid, GRID_SIZE):
    """Place block on grid at (x,y) with given color (modifies grid in-place).
    
    Args:
        block: Block matrix to place
        x, y: Top-left grid coordinates
        color: RGB color for the block
        grid: Grid to modify
        GRID_SIZE: For bounds checking (debug)
    """
    for dy, row in enumerate(block):
        for dx, cell in enumerate(row):
            if cell:
                assert grid[y+dy][x+dx] == BLACK, "Overwriting existing block!"
                grid[y+dy][x+dx] = color

def no_valid_moves_left(grid, blocks, GRID_SIZE):
    """Check if no valid placements remain for any blocks.
    
    Args:
        grid: Current game state
        blocks: List of (block, color) remaining
        GRID_SIZE: Grid dimensions
        
    Returns:
        True if no valid moves remain
    """
    if all(cell != BLACK for row in grid for cell in row):
        return True
        
    for block, _ in blocks:
        for rotation in get_rotations(block):
            h, w = len(rotation), len(rotation[0])
            for y in range(GRID_SIZE - h + 1):
                for x in range(GRID_SIZE - w + 1):
                    if can_place_block(rotation, x, y, grid, GRID_SIZE):
                        return False
    return True

def clear_completed_lines(grid, GRID_SIZE):
    """Clear fully filled rows/columns and return count of cleared lines.
    
    Args:
        grid: Grid to check and modify
        GRID_SIZE: Grid dimensions
        
    Returns:
        Number of lines cleared (rows + columns)
    """
    rows = [y for y in range(GRID_SIZE) if all(cell != BLACK for cell in grid[y])]
    cols = [x for x in range(GRID_SIZE) if all(grid[y][x] != BLACK for y in range(GRID_SIZE))]
    
    for y in rows: grid[y] = [BLACK] * GRID_SIZE
    for x in cols:
        for y in range(GRID_SIZE): grid[y][x] = BLACK
    
    return len(rows) + len(cols)

def snap_to_grid(x, y, block, grid, GRID_SIZE, snap_range=20):
    """Snap screen coordinates to nearest valid grid position within range.
    
    Args:
        x, y: Pixel coordinates
        block: Block being placed
        grid: Current game state
        GRID_SIZE: Grid dimensions
        snap_range: Max pixel distance for snapping
        
    Returns:
        (grid_x, grid_y) if valid snap exists, else None
    """
    grid_x, grid_y = round(x / BLOCK_SIZE), round(y / BLOCK_SIZE)
    if (abs(x - grid_x * BLOCK_SIZE) <= snap_range and
        abs(y - grid_y * BLOCK_SIZE) <= snap_range and
        can_place_block(block, grid_x, grid_y, grid, GRID_SIZE)):
        return grid_x, grid_y